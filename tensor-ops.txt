-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tensor manipulation operations with tensorflow-style
--   automatic differentiation
--   
--   Please see README.md
@package tensor-ops
@version 0.1.0.0

module Type.Family.Nat.Util
appendLengths :: Length n -> Length m -> (Len (n ++ m) :~: (Len n + Len m))

module Type.Class.Higher.Util
traverse1_ :: (Foldable1 t, Applicative h) => (forall a. f a -> h c) -> t f b -> h ()
mapM1_ :: (Foldable1 t, Applicative h) => (forall a. f a -> h c) -> t f b -> h ()
forM1_ :: (Foldable1 t, Applicative h) => t f b -> (forall a. f a -> h c) -> h ()
all1 :: Foldable1 t => (forall a. f a -> Bool) -> t f b -> Bool
produceEq1 :: Eq1 f :- Eq (f a)

module GHC.TypeLits.Util
data Inductive :: Nat -> Type
[NatZ] :: Inductive 0
[NatS] :: KnownNat n => !(Proxy n) -> Inductive (n + 1)
inductive :: forall n. KnownNat n => Proxy n -> Inductive n

module Data.Type.Nat.Util
withNat :: Integer -> (forall n. Nat n -> Maybe r) -> Maybe r

module Data.Vector.Sized
type Vector n = VectorT n I
newtype VectorT :: Nat -> (Type -> Type) -> Type -> Type
[UnsafeV] :: {getV :: Vector (f a)} -> VectorT n f a
mkVectorT :: forall n f a. KnownNat n => Vector (f a) -> Maybe (VectorT n f a)
mkVector :: forall n a. KnownNat n => Vector a -> Maybe (Vector n a)
mkVectorT' :: forall n f a. KnownNat n => Vector (f a) -> VectorT n f a
mkVector' :: forall n a. KnownNat n => Vector a -> Vector n a
generate :: forall n f a. KnownNat n => (Finite n -> f a) -> VectorT n f a
generateA :: forall n f a g. (KnownNat n, Applicative g) => (Finite n -> g (f a)) -> g (VectorT n f a)
replicate :: KnownNat n => f a -> VectorT n f a
(!) :: VectorT n f a -> Finite n -> f a
(!!) :: Vector n a -> Finite n -> a
withVectorT :: forall f a r. Vector (f a) -> (forall n. KnownNat n => VectorT n f a -> r) -> r
withVector :: forall a r. Vector a -> (forall n. KnownNat n => Vector n a -> r) -> r
liftVec :: (Applicative f, Traversable g) => (g a -> b) -> g (f a) -> f b
vecFunc :: KnownNat n => (a -> Vector n b) -> Vector n (a -> b)
vap :: (f a -> g b -> h c) -> VectorT n f a -> VectorT n g b -> VectorT n h c
vmap :: (f a -> g b) -> VectorT n f a -> VectorT n g b
data Uncons :: Nat -> (Type -> Type) -> Type -> Type
[VNil] :: Uncons 0 f a
[VCons] :: KnownNat n => !(f a) -> !(VectorT n f a) -> Uncons (n + 1) f a
uncons :: forall n f a. KnownNat n => VectorT n f a -> Uncons n f a
fromUncons :: Uncons n f a -> VectorT n f a
cons :: f a -> VectorT n f a -> VectorT (n + 1) f a
empty :: VectorT 0 f a
head :: VectorT (m + 1) f a -> f a
tail :: VectorT (m + 1) f a -> VectorT m f a
itraverse :: Applicative h => (Finite n -> f a -> h (g b)) -> VectorT n f a -> h (VectorT n g b)
instance GHC.Generics.Generic (Data.Vector.Sized.VectorT n f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Data.Vector.Sized.VectorT n f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Vector.Sized.VectorT n f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Vector.Sized.VectorT n f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Vector.Sized.VectorT n f)
instance (GHC.TypeLits.KnownNat n, Data.Distributive.Distributive f) => Data.Distributive.Distributive (Data.Vector.Sized.VectorT n f)
instance Control.DeepSeq.NFData (f a) => Control.DeepSeq.NFData (Data.Vector.Sized.VectorT n f a)
instance (GHC.TypeLits.KnownNat n, GHC.Base.Applicative f) => GHC.Base.Applicative (Data.Vector.Sized.VectorT n f)

module Data.Type.Vector.Util
splitVec :: Nat n -> VecT (n + m) f a -> (VecT n f a, VecT m f a)
zipVecs :: (Traversable g, Applicative g, Known Nat n) => (VecT m g a -> b) -> VecT m g (VecT n g a) -> VecT n g b
liftVec :: (Applicative f, Traversable g) => (VecT m g a -> b) -> VecT m g (f a) -> f b
zipVecsD :: (Distributive g, Known Nat n) => (VecT m g a -> b) -> VecT m g (VecT n g a) -> VecT n g b
liftVecD :: (Distributive f, Distributive g) => (VecT m g a -> b) -> VecT m g (f a) -> f b
curryV :: (VecT (S n) f a -> b) -> f a -> VecT n f a -> b
uncurryV :: (f a -> VecT n f a -> b) -> VecT (S n) f a -> b
append' :: VecT n f a -> VecT m f a -> VecT (n + m) f a
vecFunc :: Known Nat n => (a -> Vec n b) -> Vec n (a -> b)
unVecFunc :: Vec n (a -> b) -> a -> Vec n b
vgenA :: Applicative g => Nat n -> (Fin n -> g (f a)) -> g (VecT n f a)
uniformVec :: Eq (f a) => VecT m f a -> Maybe (f a)
instance (Type.Class.Known.Known Data.Type.Nat.Nat n, Data.Distributive.Distributive f) => Data.Distributive.Distributive (Data.Type.Vector.VecT n f)
instance Control.DeepSeq.NFData (f a) => Control.DeepSeq.NFData (Data.Type.Vector.VecT n f a)

module Data.Type.Combinator.Util
newtype Flip2 p b a c
[Flip2] :: {getFlip2 :: p a b c} -> Flip2 p b a c
instance forall k k1 k2 (p :: k1 -> k -> k2 -> *) (b :: k) (a :: k1) (c :: k2). GHC.Generics.Generic (Data.Type.Combinator.Util.Flip2 p b a c)
instance forall k k1 (p :: k1 -> k -> * -> *) (a :: k1) (b :: k). GHC.Base.Functor (p a b) => GHC.Base.Functor (Data.Type.Combinator.Util.Flip2 p b a)
instance forall k k1 (p :: k1 -> k -> * -> *) (a :: k1) (b :: k). GHC.Base.Applicative (p a b) => GHC.Base.Applicative (Data.Type.Combinator.Util.Flip2 p b a)
instance forall k k1 (p :: k1 -> k -> * -> *) (a :: k1) (b :: k). Data.Foldable.Foldable (p a b) => Data.Foldable.Foldable (Data.Type.Combinator.Util.Flip2 p b a)
instance forall k k1 (p :: k1 -> k -> * -> *) (a :: k1) (b :: k). Data.Traversable.Traversable (p a b) => Data.Traversable.Traversable (Data.Type.Combinator.Util.Flip2 p b a)
instance forall k k1 k2 (p :: k1 -> k -> k2 -> *) (a :: k1) (b :: k) (c :: k2). GHC.Show.Show (p a b c) => GHC.Show.Show (Data.Type.Combinator.Util.Flip2 p b a c)
instance forall k k1 k2 (p :: k1 -> k -> k2 -> *) (a :: k1) (b :: k) (c :: k2). GHC.Num.Num (p a b c) => GHC.Num.Num (Data.Type.Combinator.Util.Flip2 p b a c)
instance GHC.Generics.Generic (Data.Type.Combinator.I a)
instance Data.Distributive.Distributive Data.Type.Combinator.I
instance forall k k1 k2 (p :: k1 -> k -> k2 -> *) (a :: k1) (b :: k) (c :: k2). Control.DeepSeq.NFData (p a b c) => Control.DeepSeq.NFData (Data.Type.Combinator.Util.Flip2 p b a c)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Type.Combinator.I a)
instance forall k k1 (p :: k1 -> k -> * -> *) (a :: k1) (b :: k). Data.Distributive.Distributive (p a b) => Data.Distributive.Distributive (Data.Type.Combinator.Util.Flip2 p b a)

module Type.Family.List.Util
reverseSnoc :: forall a as. Length as -> Proxy a -> (Reverse (a : as) :~: (Reverse as >: a))
snocReverse :: forall p a as. Length as -> p a -> (Reverse (as >: a) :~: (a : Reverse as))
reverseReverse :: Length as -> (as :~: Reverse (Reverse as))
reverseConcat :: Length as -> Length bs -> (Reverse (as ++ bs) :~: (Reverse bs ++ Reverse as))
appendNil :: Length ms -> ((ms ++ '[]) :~: ms)
appendAssoc :: Length ms -> Length ns -> Length os -> (((ms ++ ns) ++ os) :~: (ms ++ (ns ++ os)))
appendSnoc :: Length ms -> p n -> ((ms >: n) :~: (ms ++ '[n]))

module Data.Type.Length.Util
append' :: Length ns -> Length ms -> Length (ns ++ ms)
reverse' :: forall ns. Length ns -> Length (Reverse ns)
(>:) :: Length ns -> Proxy n -> Length (ns >: n)
data SnocLength :: [a] -> Type
[SnocZ] :: SnocLength '[]
[SnocS] :: SnocLength as -> Proxy a -> SnocLength (as >: a)
snocLengthHelp :: forall as bs. Length bs -> SnocLength bs -> Length as -> SnocLength (bs ++ as)

-- | could this be unsafeCoerce?
snocLength :: Length as -> SnocLength as

-- | could just be unsafeCoerce lol
snocLengthLength :: SnocLength as -> Length as
snocLengthReverse :: SnocLength as -> Length (Reverse as)

module Data.Type.Uniform
data Uniform :: a -> [a] -> Type
[UØ] :: Uniform a '[]
[US] :: Uniform a as -> Uniform a (a : as)
uniformLength :: Uniform n ns -> Length ns
appendUniform :: Uniform o ns -> Uniform o ms -> Uniform o (ns ++ ms)
instance forall a (a1 :: a) (as :: [a]). GHC.Show.Show (Data.Type.Uniform.Uniform a1 as)
instance forall a (n :: a). Type.Class.Known.Known (Data.Type.Uniform.Uniform n) '[]
instance forall a (n :: a) (ns :: [a]). Type.Class.Known.Known (Data.Type.Uniform.Uniform n) ns => Type.Class.Known.Known (Data.Type.Uniform.Uniform n) (n : ns)
instance forall a (ms :: [a]) (m :: a). Type.Class.Witness.Witness Type.Family.Constraint.ØC (Type.Class.Known.Known Data.Type.Length.Length ms) (Data.Type.Uniform.Uniform m ms)

module Data.Type.Product.Util
splitProd :: Length ns -> Prod f (ns ++ ms) -> (Prod f ns, Prod f ms)
takeProd :: Length ns -> Length ms -> Prod f (ns ++ ms) -> Prod f ns
overProdInit :: Length ns -> Length os -> (Prod g ns -> Prod g ms) -> Prod g (ns ++ os) -> Prod g (ms ++ os)
prodInit :: Functor f => Length ns -> Length os -> (Prod g ns -> f (Prod g ms)) -> Prod g (ns ++ os) -> f (Prod g (ms ++ os))
overProdSplit :: Length ns -> (Prod g ns -> Prod g ms) -> (Prod g os -> Prod g ps) -> Prod g (ns ++ os) -> Prod g (ms ++ ps)
prodSplit :: Applicative f => Length ns -> (Prod g ns -> f (Prod g ms)) -> (Prod g os -> f (Prod g ps)) -> Prod g (ns ++ os) -> f (Prod g (ms ++ ps))
prodSplit' :: Functor f => Length ns -> ((Prod g ns, Prod g os) -> f (Prod g ms, Prod g ps)) -> Prod g (ns ++ os) -> f (Prod g (ms ++ ps))
vecToProd :: forall a b f g as. (f b -> g a) -> Uniform a as -> VecT (Len as) f b -> Prod g as
prodToVec :: forall a b as f g. (f a -> g b) -> Uniform a as -> Prod f as -> VecT (Len as) g b
unselect :: forall as bs f. (Known Length as, Known Length bs) => Prod (Index as) bs -> Prod f bs -> Prod (Maybe :.: f) as
replicate :: forall a f as. f a -> Uniform a as -> Prod f as
zipProd :: Prod f as -> Prod g as -> Prod (f :&: g) as
zipProd3 :: Prod f as -> Prod g as -> Prod h as -> Prod (f :&: (g :&: h)) as
prodLength :: Prod f as -> Length as
instance forall k (f :: k -> *) (as :: [k]). Data.Type.Index.Every Control.DeepSeq.NFData (f Type.Family.List.<$> as) => Control.DeepSeq.NFData (Data.Type.Product.Prod f as)

module Data.Type.SnocProd
data SnocProd :: (a -> Type) -> [a] -> Type
[ØS] :: SnocProd f '[]
[:&] :: SnocProd f as -> f a -> SnocProd f (as >: a)
snocProdHelp :: forall f as bs. Length bs -> SnocProd f bs -> Length as -> Prod f as -> SnocProd f (bs ++ as)
snocProd :: Prod f as -> SnocProd f as
snocProdLength :: SnocProd f as -> Length as
snocProdReverse :: SnocProd f as -> Prod f (Reverse as)
reverseSnocProd :: Prod f as -> SnocProd f (Reverse as)

-- | An implementation of reverse' for Prod that runs in O(n) instead of
--   O(n^2)
prodReverse' :: Prod f as -> Prod f (Reverse as)

module Data.Type.Sing
singLength :: Sing ns -> Length ns
singProd :: Sing as -> Prod Sing as
prodSing :: Prod Sing as -> Sing as
splitSing :: Length ns -> Sing (ns ++ ms) -> (Sing ns, Sing ms)
singProdNat :: forall (as :: [N]). Sing as -> Prod Nat as
entailNat :: forall n. (SingI n :- Known Nat n)
singSings :: forall ns. SingI ns :- ListC (SingI <$> ns)
witSings :: forall ns. Sing ns -> Wit (ListC (SingI <$> ns))
entailEvery :: forall (as :: [k]) (f :: k -> Constraint). (forall (a :: k). SingI a :- f a) -> (SingI as :- Every f as)
singUniform :: Uniform a (b : bs) -> (SingI b :- SingI a)
entailSing :: forall a b. (Sing a -> Sing b) -> (SingI a :- SingI b)
entailSing2 :: forall a b c. (Sing a -> Sing b -> Sing c) -> ((SingI a, SingI b) :- SingI c)
singWit :: forall a p q t. (p, Witness p q t) => (Sing a -> t) -> (SingI a :- q)
(%:++) :: Sing as -> Sing bs -> Sing (as ++ bs)
infixr 5 %:++
sReverse :: Sing as -> Sing (Reverse as)
sSnoc :: Sing as -> Sing a -> Sing (as >: a)
sOnly :: Sing a -> Sing '[a]
instance forall k (a :: k). Type.Class.Witness.Witness Type.Family.Constraint.ØC (Data.Singletons.SingI a) (Data.Singletons.Sing a)
instance Type.Class.Known.Known Data.Type.Nat.Nat a => Data.Singletons.SingI a

module TensorOps.NatKind
class NatKind k where type FromNat (n :: Nat) :: k type Succ (n :: k) :: k type IndexN k :: k -> Type where {
    type family FromNat (n :: Nat) :: k;
    type family Succ (n :: k) :: k;
    type family IndexN k :: k -> Type;
}
sFromNat :: NatKind k => Sing (n :: Nat) -> Sing (FromNat n :: k)
sSucc :: NatKind k => Sing (n :: k) -> Sing (Succ n :: k)
someNatKind :: NatKind k => Integer -> SomeSing k
withNatKind :: NatKind k => Integer -> (forall (n :: k). Sing n -> r) -> r
instance TensorOps.NatKind.NatKind Type.Family.Nat.N
instance TensorOps.NatKind.NatKind GHC.Types.Nat

module Data.Nested
class NatKind k => Vec (v :: k -> Type -> Type)
vHead :: Vec v => p j -> v (Succ j) a -> a
vTail :: Vec v => v (Succ j) a -> v j a
vGenA :: (Vec v, Applicative f) => Sing j -> (IndexN k j -> f a) -> f (v j a)
vIndex :: Vec v => IndexN k j -> v j a -> a
vUncons :: Vec v => Sing j -> v j a -> Uncons v j a
vEmpty :: Vec v => v (FromNat 0) a
vCons :: Vec v => a -> v j a -> v (Succ j) a
vITraverse :: (Vec v, Applicative f) => (IndexN k j -> a -> f b) -> v j a -> f (v j b)
class Nesting (w :: k -> Type) (c :: j -> Constraint) (v :: k -> j -> j)
nesting :: Nesting w c v => w i -> c a :- c (v i a)
class Nesting1 (w :: k -> Type) (c :: j -> Constraint) (v :: k -> j)
nesting1 :: Nesting1 w c v => w a -> Wit (c (v a))
nesting1Every :: forall p w c v as. Nesting1 w c v => p v -> Prod w as -> Wit (Every c (v <$> as))
data Nested :: (k -> Type -> Type) -> [k] -> Type -> Type
genNested :: Vec (v :: k -> Type -> Type) => Sing ns -> (Prod (IndexN k) ns -> a) -> Nested v ns a
genNestedA :: (Vec (v :: k -> Type -> Type), Applicative f) => Sing ns -> (Prod (IndexN k) ns -> f a) -> f (Nested v ns a)
indexNested :: Vec (v :: k -> Type -> Type) => Prod (IndexN k) ns -> Nested v ns a -> a
indexNested' :: Vec (v :: k -> Type -> Type) => Prod (IndexN k) ms -> Nested v (ms ++ ns) a -> Nested v ns a

-- | Transpose by iteratively sequencing/distributing layers
transpose :: forall v os a. (Nesting1 Proxy Functor v, Nesting1 Proxy Foldable v, Nesting1 Proxy Traversable v, Nesting1 Sing Distributive v) => Sing os -> Nested v os a -> Nested v (Reverse os) a

-- | Transpose by populating a new <a>Nested</a> from scratch
transpose' :: Vec v => Length os -> Sing (Reverse os) -> Nested v os a -> Nested v (Reverse os) a
gmul' :: forall ms os ns v a. (Nesting1 Proxy Functor v, Nesting1 Sing Applicative v, Nesting1 Proxy Foldable v, Nesting1 Proxy Traversable v, Nesting1 Sing Distributive v, SingI ns, SingI (Reverse os), Num a, Vec v) => Length ms -> Length os -> Length ns -> Nested v (ms ++ os) a -> Nested v (Reverse os ++ ns) a -> Nested v (ms ++ ns) a
diagNV :: (Vec v, Nesting1 Proxy Functor v) => Sing n -> Uniform n ms -> Nested v (n : (n : ms)) a -> Nested v '[n] a
joinNested :: forall v ns ms a. Nesting1 Proxy Functor v => Nested v ns (Nested v ms a) -> Nested v (ns ++ ms) a
nIxRows :: forall k (v :: k -> Type -> Type) ns ms a b f. (Nesting1 Proxy Functor v, Applicative f, Vec v) => Length ns -> (Prod (IndexN k) ns -> Nested v ms a -> f b) -> Nested v (ns ++ ms) a -> f (Nested v ns b)
vGen :: Vec (v :: k -> Type -> Type) => Sing j -> (IndexN k j -> a) -> v j a
itraverseNested :: forall k (v :: k -> Type -> Type) (ns :: [k]) a b f. (Applicative f, Vec v) => (Prod (IndexN k) ns -> a -> f b) -> Nested v ns a -> f (Nested v ns b)
liftNested :: Distributive (Nested v ns) => (Vec m (Vec n a -> a)) -> Vec n (Nested v ns a) -> Vec m (Nested v ns a)
unScalar :: Nested v '[] a -> a
unNest :: Nested v (j : js) a -> v j (Nested v js a)
unVector :: Functor (v j) => Nested v '[j] a -> v j a
instance Data.Nested.Vec (Data.Type.Combinator.Util.Flip2 Data.Vector.Sized.VectorT Data.Type.Combinator.I)
instance Data.Nested.Vec (Data.Type.Combinator.Util.Flip2 Data.Type.Vector.VecT Data.Type.Combinator.I)
instance Data.Nested.Nesting w Control.DeepSeq.NFData (Data.Type.Combinator.Util.Flip2 Data.Vector.Sized.VectorT Data.Type.Combinator.I)
instance GHC.Base.Functor f => Data.Nested.Nesting1 w GHC.Base.Functor (Data.Type.Combinator.Util.Flip2 Data.Vector.Sized.VectorT f)
instance GHC.Base.Applicative f => Data.Nested.Nesting1 Data.Singletons.Sing GHC.Base.Applicative (Data.Type.Combinator.Util.Flip2 Data.Vector.Sized.VectorT f)
instance Data.Foldable.Foldable f => Data.Nested.Nesting1 w Data.Foldable.Foldable (Data.Type.Combinator.Util.Flip2 Data.Vector.Sized.VectorT f)
instance Data.Traversable.Traversable f => Data.Nested.Nesting1 w Data.Traversable.Traversable (Data.Type.Combinator.Util.Flip2 Data.Vector.Sized.VectorT f)
instance Data.Distributive.Distributive f => Data.Nested.Nesting1 Data.Singletons.Sing Data.Distributive.Distributive (Data.Type.Combinator.Util.Flip2 Data.Vector.Sized.VectorT f)
instance Data.Nested.Nesting w Control.DeepSeq.NFData (Data.Type.Combinator.Util.Flip2 Data.Type.Vector.VecT Data.Type.Combinator.I)
instance GHC.Base.Functor f => Data.Nested.Nesting1 w GHC.Base.Functor (Data.Type.Combinator.Util.Flip2 Data.Type.Vector.VecT f)
instance GHC.Base.Applicative f => Data.Nested.Nesting1 Data.Singletons.Sing GHC.Base.Applicative (Data.Type.Combinator.Util.Flip2 Data.Type.Vector.VecT f)
instance Data.Foldable.Foldable f => Data.Nested.Nesting1 w Data.Foldable.Foldable (Data.Type.Combinator.Util.Flip2 Data.Type.Vector.VecT f)
instance Data.Traversable.Traversable f => Data.Nested.Nesting1 w Data.Traversable.Traversable (Data.Type.Combinator.Util.Flip2 Data.Type.Vector.VecT f)
instance Data.Distributive.Distributive f => Data.Nested.Nesting1 Data.Singletons.Sing Data.Distributive.Distributive (Data.Type.Combinator.Util.Flip2 Data.Type.Vector.VecT f)
instance forall k a (v :: k -> * -> *) (js :: [k]). (Control.DeepSeq.NFData a, Data.Nested.Nesting Data.Proxy.Proxy Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (Data.Nested.Nested v js a)
instance forall k a (v :: k -> GHC.Types.Type -> GHC.Types.Type) (js :: [k]). (GHC.Num.Num a, GHC.Base.Applicative (Data.Nested.Nested v js)) => GHC.Num.Num (Data.Nested.Nested v js a)
instance forall k (v :: k -> * -> *) (js :: [k]). Data.Nested.Nesting1 Data.Proxy.Proxy GHC.Base.Functor v => GHC.Base.Functor (Data.Nested.Nested v js)
instance forall k (js :: [k]) (v :: k -> * -> *). (Data.Singletons.SingI js, Data.Nested.Nesting1 Data.Singletons.Sing GHC.Base.Applicative v, Data.Nested.Nesting1 Data.Proxy.Proxy GHC.Base.Functor v) => GHC.Base.Applicative (Data.Nested.Nested v js)
instance forall k (v :: k -> * -> *) (js :: [k]). Data.Nested.Nesting1 Data.Proxy.Proxy Data.Foldable.Foldable v => Data.Foldable.Foldable (Data.Nested.Nested v js)
instance forall k (v :: k -> * -> *) (js :: [k]). (Data.Nested.Nesting1 Data.Proxy.Proxy GHC.Base.Functor v, Data.Nested.Nesting1 Data.Proxy.Proxy Data.Foldable.Foldable v, Data.Nested.Nesting1 Data.Proxy.Proxy Data.Traversable.Traversable v) => Data.Traversable.Traversable (Data.Nested.Nested v js)
instance forall k (v :: k -> GHC.Types.Type -> GHC.Types.Type) (js :: [k]). (Data.Nested.Vec v, Data.Singletons.SingI js, Data.Nested.Nesting1 Data.Proxy.Proxy GHC.Base.Functor v) => Data.Distributive.Distributive (Data.Nested.Nested v js)

module TensorOps.Types
class NatKind k => Tensor (t :: [k] -> Type) where type ElemT t :: Type where {
    type family ElemT t :: Type;
}
liftT :: (Tensor t, SingI o) => (Vec m (Vec n (ElemT t) -> ElemT t)) -> Vec n (t o) -> Vec m (t o)
gmul :: (Tensor t, SingI (Reverse os ++ ns)) => Length ms -> Length os -> Length ns -> t (ms ++ os) -> t (Reverse os ++ ns) -> t (ms ++ ns)
transp :: (Tensor t, SingI ns, SingI (Reverse ns)) => t ns -> t (Reverse ns)
diag :: (Tensor t, SingI ns) => Uniform n ns -> t '[n] -> t ns
getDiag :: (Tensor t, SingI n) => Uniform n ns -> t (n : (n : ns)) -> t '[n]
genRand :: (Tensor t, ContGen d, PrimMonad m, SingI ns) => d -> Gen (PrimState m) -> m (t ns)
generateA :: (Tensor t, Applicative f, SingI ns) => (Prod (IndexN k) ns -> f (ElemT t)) -> f (t ns)
ixRows :: (Tensor t, Applicative f) => Length ms -> (Prod (IndexN k) ms -> t ns -> f (t os)) -> t (ms ++ ns) -> f (t (ms ++ os))
(!) :: Tensor t => t ns -> Prod (IndexN k) ns -> ElemT t
type TensorOp = OpPipe TOp

-- | A kludge to get around lack of impredicative types in Haskell
newtype VFunc n
VF :: (forall a. Floating a => Vec n a -> a) -> VFunc n
[getVF] :: VFunc n -> forall a. Floating a => Vec n a -> a
data TOp :: [[k]] -> [[k]] -> Type

-- | Lift any `R^N -&gt; R^M` function over every element in a n-tensor
--   list, producing a m-tensor list.
[Lift] :: Uniform o ns -> Uniform o ms -> Vec (Len ms) (VFunc (Len ns)) -> TOp ns ms

-- | Generalized tensor product
[GMul] :: Length ms -> Length os -> Length ns -> TOp '[ms ++ os, Reverse os ++ ns] '[ms ++ ns]

-- | Transpose (reverse indices)
--   
--   TODO: allow for arbitrary permutation
[Transp] :: Length ns -> TOp '[ns] '[Reverse ns]
[Shuffle] :: Prod (Index ns) ms -> TOp ns ms

-- | TODO: replace with <tt>syntactic</tt>?
data OpPipe :: ([k] -> [k] -> Type) -> [k] -> [k] -> Type
[OPØ] :: OpPipe f a a
[Pop] :: Sing a -> Sing b -> Sing d -> f a b -> OpPipe f (b ++ d) c -> OpPipe f (a ++ d) c
pappend :: forall a b c d f. Sing a -> Sing b -> Sing d -> OpPipe f a b -> OpPipe f (b ++ d) c -> OpPipe f (a ++ d) c
pop :: forall a b c d f. (SingI a, SingI b, SingI d) => Length d -> f a b -> OpPipe f (b ++ d) c -> OpPipe f (a ++ d) c
(~.) :: (SingI a, SingI b, SingI d) => (Length a, Length d, f a b) -> OpPipe f (b ++ d) c -> OpPipe f (a ++ d) c
infixr 4 ~.
instance Type.Class.Higher.Eq1 Data.Finite.Internal.Finite

module TensorOps.BLAS
data BShape a_a10um
BV :: !a_a10um -> BShape a_a10um
BM :: !a_a10um -> !a_a10um -> BShape a_a10um
type BVSym1 (t_a10CZ :: a1627630162) = BV t_a10CZ
data BVSym0 (l_a10D0 :: TyFun a1627630162 (BShape a1627630162))
BVSym0KindInference :: BVSym0
type BMSym2 (t_a10D2 :: a1627630162) (t_a10D3 :: a1627630162) = BM t_a10D2 t_a10D3
data BMSym1 (l_a10D7 :: a1627630162) (l_a10D6 :: TyFun a1627630162 (BShape a1627630162))
BMSym1KindInference :: BMSym1
data BMSym0 (l_a10D4 :: TyFun a1627630162 (TyFun a1627630162 (BShape a1627630162) -> Type))
BMSym0KindInference :: BMSym0
type Compare_1627630999Sym2 (t_a10HT :: BShape a1627630162) (t_a10HU :: BShape a1627630162) = Compare_1627630999 t_a10HT t_a10HU
data Compare_1627630999Sym1 (l_a10HY :: BShape a1627630162) (l_a10HX :: TyFun (BShape a1627630162) Ordering)
Compare_1627630999Sym1KindInference :: Compare_1627630999Sym1
data Compare_1627630999Sym0 (l_a10HV :: TyFun (BShape a1627630162) (TyFun (BShape a1627630162) Ordering -> Type))
Compare_1627630999Sym0KindInference :: Compare_1627630999Sym0
type SBShape = (Sing :: BShape a_a10um -> Type)
type BShapeDimsSym1 (t_a12b3 :: BShape k1627631155) = BShapeDims t_a12b3
data BShapeDimsSym0 (l_a12b4 :: TyFun (BShape k1627631155) [k1627631155])
BShapeDimsSym0KindInference :: BShapeDimsSym0
class NatKind k => BLAS (b :: BShape k -> Type) where type ElemB b :: Type where {
    type family ElemB b :: Type;
}
axpy :: BLAS b => ElemB b -> b (BV n) -> Maybe (b (BV n)) -> b (BV n)
dot :: BLAS b => b (BV n) -> b (BV n) -> ElemB b
norm :: BLAS b => b (BV n) -> ElemB b
ger :: BLAS b => b (BV n) -> b (BV m) -> b (BM n m)
gemv :: BLAS b => ElemB b -> b (BM n m) -> b (BV m) -> Maybe (ElemB b, b (BV n)) -> b (BV n)
gemm :: BLAS b => ElemB b -> b (BM n o) -> b (BM o m) -> Maybe (ElemB b, b (BM n m)) -> b (BM n m)
indexB :: BLAS b => Prod (IndexN k) (BShapeDims s) -> b s -> ElemB b
transp :: BLAS b => b (BM n m) -> b (BM m n)
data BTensor :: (k -> Type -> Type) -> (BShape k -> Type) -> [k] -> Type
[BTS] :: !(ElemB b) -> BTensor v b '[]
[BTV] :: !(b (BV n)) -> BTensor v b '[n]
[BTM] :: !(b (BM n m)) -> BTensor v b '[n, m]
[BTN] :: !(v n (BTensor v b (o : (m : ns)))) -> BTensor v b (n : (o : (m : ns)))
data ArbiProd :: (k -> Type) -> f k -> Type
[AP] :: ArbiProd f as
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TensorOps.BLAS.BShapeDimsSym0
instance forall k (v :: k -> GHC.Types.Type -> GHC.Types.Type) (b :: TensorOps.BLAS.BShape k -> GHC.Types.Type). (Data.Nested.Vec v, TensorOps.BLAS.BLAS b, TensorOps.NatKind.NatKind k) => TensorOps.Types.Tensor (TensorOps.BLAS.BTensor v b)
instance GHC.Base.Functor TensorOps.BLAS.BShape
instance GHC.Classes.Ord a0 => GHC.Classes.Ord (TensorOps.BLAS.BShape a0)
instance GHC.Classes.Eq a0 => GHC.Classes.Eq (TensorOps.BLAS.BShape a0)
instance GHC.Show.Show a0 => GHC.Show.Show (TensorOps.BLAS.BShape a0)
instance Data.Singletons.Prelude.Eq.PEq 'Data.Proxy.Proxy
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TensorOps.BLAS.BVSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TensorOps.BLAS.BMSym1
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TensorOps.BLAS.BMSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TensorOps.BLAS.Compare_1627630999Sym1
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings TensorOps.BLAS.Compare_1627630999Sym0
instance Data.Singletons.Prelude.Ord.POrd 'Data.Proxy.Proxy
instance Data.Singletons.SingKind a0 => Data.Singletons.SingKind (TensorOps.BLAS.BShape a0)
instance Data.Singletons.Prelude.Eq.SEq a0 => Data.Singletons.Prelude.Eq.SEq (TensorOps.BLAS.BShape a0)
instance Data.Singletons.Decide.SDecide a0 => Data.Singletons.Decide.SDecide (TensorOps.BLAS.BShape a0)
instance Data.Singletons.Prelude.Ord.SOrd a0 => Data.Singletons.Prelude.Ord.SOrd (TensorOps.BLAS.BShape a0)
instance forall a0 (n0 :: a0). Data.Singletons.SingI n0 => Data.Singletons.SingI ('TensorOps.BLAS.BV n0)
instance forall a0 (n0 :: a0) (n1 :: a0). (Data.Singletons.SingI n0, Data.Singletons.SingI n1) => Data.Singletons.SingI ('TensorOps.BLAS.BM n0 n1)

module TensorOps.Backend.NTensor
data NTensor :: (k -> Type -> Type) -> Type -> [k] -> Type
type LTensor = NTensor (Flip2 VecT I) Double
type VTensor = NTensor (Flip2 VectorT I) Double
instance forall k (v :: k -> GHC.Types.Type -> GHC.Types.Type) a (ns :: [k]). GHC.Generics.Generic (TensorOps.Backend.NTensor.NTensor v a ns)
instance forall a k (v :: k -> * -> *) (ns :: [k]). (Control.DeepSeq.NFData a, Data.Nested.Nesting Data.Proxy.Proxy Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (TensorOps.Backend.NTensor.NTensor v a ns)
instance forall k a (v :: k -> * -> *) (w :: [k] -> GHC.Types.Type). (Control.DeepSeq.NFData a, Data.Nested.Nesting Data.Proxy.Proxy Control.DeepSeq.NFData v) => Data.Nested.Nesting1 w Control.DeepSeq.NFData (TensorOps.Backend.NTensor.NTensor v a)
instance forall k (k1 :: k) k2 (v :: k2 -> GHC.Types.Type -> GHC.Types.Type) a. (Data.Nested.Vec v, a ~ GHC.Types.Double, Data.Nested.Nesting1 Data.Proxy.Proxy GHC.Base.Functor v, Data.Nested.Nesting1 Data.Singletons.Sing GHC.Base.Applicative v, Data.Nested.Nesting1 Data.Proxy.Proxy Data.Foldable.Foldable v, Data.Nested.Nesting1 Data.Proxy.Proxy Data.Traversable.Traversable v, Data.Nested.Nesting1 Data.Singletons.Sing Data.Distributive.Distributive v, Type.Class.Higher.Eq1 (TensorOps.NatKind.IndexN k2)) => TensorOps.Types.Tensor (TensorOps.Backend.NTensor.NTensor v a)

module TensorOps.Run
runTOp :: forall (ns :: [[k]]) (ms :: [[k]]) (t :: [k] -> *). (Tensor t, Floating (ElemT t)) => Sing ns -> Sing ms -> TOp ns ms -> Prod t ns -> Prod t ms
runTensorOp :: forall t ns ms. (Tensor t, Floating (ElemT t)) => TensorOp ns ms -> Prod t ns -> Prod t ms

module TensorOps.Tensor
konst :: (Tensor t, SingI n) => ElemT t -> t n
map :: forall k (o :: [k]) (t :: [k] -> Type). (SingI o, Tensor t) => (ElemT t -> ElemT t) -> t o -> t o
zip :: (SingI o, Tensor t) => (Vec n (ElemT t) -> ElemT t) -> Vec n (t o) -> t o
zip2 :: (SingI o, Tensor t) => (ElemT t -> ElemT t -> ElemT t) -> t o -> t o -> t o
zip3 :: (SingI o, Tensor t) => (ElemT t -> ElemT t -> ElemT t -> ElemT t) -> t o -> t o -> t o -> t o
gradLift :: forall o n m t. (Tensor t, Floating (ElemT t), SingI o) => Vec m (VFunc n) -> Vec n (t o) -> Vec m (t o) -> Vec n (t o)
inner :: forall t ms ns o. (Tensor t, SingI (o : ns)) => Length ms -> Length ns -> t (ms >: o) -> t (o : ns) -> t (ms ++ ns)
outer :: (Tensor t, SingI ns) => Length ms -> Length ns -> t ms -> t ns -> t (ms ++ ns)
outerV :: (Tensor t, SingI '[n]) => t '[m] -> t '[n] -> t '[m, n]
dot :: forall (t :: [k] -> Type) (m :: k). (Tensor t, SingI '[m]) => t '[m] -> t '[m] -> t '[]
matVec :: (Tensor t, SingI '[n]) => t '[m, n] -> t '[n] -> t '[m]
vecMat :: (Tensor t, SingI '[m, n]) => t '[m] -> t '[m, n] -> t '[n]
matMat :: (Tensor t, SingI '[n, o]) => t '[m, n] -> t '[n, o] -> t '[m, o]
fromList :: (Tensor t, SingI ns) => [ElemT t] -> Maybe (t ns)
generate :: forall k (t :: [k] -> Type) ns. (Tensor t, SingI ns) => (Prod (IndexN k) ns -> ElemT t) -> t ns
rows :: (Tensor t, Applicative f) => Length ms -> (t ns -> f (t os)) -> t (ms ++ ns) -> f (t (ms ++ os))
toRows :: Tensor t => t (n : ns) -> [t ns]
ixElems :: forall k f (t :: [k] -> Type) ns. (Applicative f, Tensor t, SingI ns) => (Prod (IndexN k) ns -> ElemT t -> f (ElemT t)) -> t ns -> f (t ns)
elems :: (Applicative f, Tensor t, SingI ns) => (ElemT t -> f (ElemT t)) -> t ns -> f (t ns)
itoList :: forall k (t :: [k] -> Type) ns. (Tensor t, SingI ns) => t ns -> [(Prod (IndexN k) ns, ElemT t)]
toList :: (Tensor t, SingI ns) => t ns -> [ElemT t]
unScalar :: forall t. Tensor t => t '[] -> ElemT t

module TensorOps.Gradient
gradTOp :: forall ns ms t. (Tensor t, Floating (ElemT t)) => Sing ns -> Sing ms -> TOp ns ms -> Prod t ns -> Prod t ms -> Prod t ns
gradTensorOp :: forall ns t. (Tensor t, Floating (ElemT t)) => TensorOp ns '['[]] -> Prod t ns -> Prod t ns

module TensorOps.TOp
konst :: forall n ns. Uniform n ns -> (forall a. Floating a => a) -> TOp '[] ns
map :: (forall a. Floating a => a -> a) -> TOp '[n] '[n]
mapN :: Uniform n ns -> (forall a. Floating a => a -> a) -> TOp ns ns
zip :: Uniform n ns -> (forall a. Floating a => Vec (Len ns) a -> a) -> TOp ns '[n]
zip2 :: (forall a. Floating a => a -> a -> a) -> TOp '[n, n] '[n]
zip3 :: (forall a. Floating a => a -> a -> a -> a) -> TOp '[n, n, n] '[n]
replicate :: Uniform n ns -> TOp '[n] ns
inner :: forall ms ns o. Length ms -> Length ns -> TOp '[ms >: o, o : ns] '[ms ++ ns]
dot :: TOp '['[m], '[m]] '['[]]
swap :: TOp '[ms, ns] '[ns, ms]
